{"version":3,"sources":["Components/Header.js","Components/Section.js","Components/Loader.js","Components/Message.js","assets/noPoster.png","Components/Poster.js","Routes/Home/HomePresenter.js","api.js","Routes/Home/index.js","Routes/Home/HomeContainer.js","Routes/TV/TVPresenter.js","Routes/TV/index.js","Routes/TV/TVContainer.js","Routes/Search/SearchPresenter.js","Routes/Search/index.js","Routes/Search/SearchContainer.js","Routes/Detail/DetailPresenter.js","Routes/Detail/index.js","Routes/Detail/DetailContainer.js","Components/Router.js","Components/GlobalStyles.js","Components/App.js","index.js"],"names":["ScHeader","styled","header","ScUl","ul","ScLi","li","props","current","ScLink","Link","withRouter","pathname","location","to","ScContainer","div","ScTitle","span","ScGrid","Section","title","children","Loader","role","aria-label","ScSpan","color","Message","text","ScImage","imageUrl","ScRating","ScYear","ScImageContainer","Poster","id","rating","year","isMovie","noPoster","length","substring","HomePresenter","nowPlaying","upcoming","popular","error","loading","Helmet","map","movie","poster_path","original_title","vote_average","release_date","api","axios","create","baseURL","params","api_key","language","moviesApi","get","append_to_response","term","query","tvApi","HomeContainer","state","a","data","results","this","setState","React","Component","TVPresenter","topRated","airingToday","tv","original_name","first_air_date","TVContainer","ScForm","form","ScInput","input","SearchPresenter","movieResults","tvResults","searchTerm","handleSubmit","updateSearchTerm","console","log","onSubmit","onChange","placeholder","value","SearchContainer","lodaing","event","preventDefault","searchByTerm","target","ScBackdrop","ScContent","ScCover","ScData","h1","ScItemContainer","ScItem","ScDivider","ScOverview","p","DetailPresenter","result","backdrop_path","runtime","episode_run_time","genres","genre","index","name","overview","DetailContainer","includes","match","push","history","parsedId","parseInt","isNaN","path","exact","component","Home","TV","Search","Detail","from","globalStyles","createGlobalStyle","reset","App","className","Router","GlobalStyles","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.2929d737.chunk.js","sourcesContent":["// 리액트에서 컴포넌트에 CSS 스타일을 주는 방법은 여러가지가 있다.\r\n// Header2처럼 폴더를 따로 만들고 거기에 index.js와 Header2.module.css를 통해 스타일을 줄 수도 있고 아래와 같이 styled-component를 이용할 수도 있다.\r\n// 스타일 컴포넌트를 사용하기 위해 import해왔다.\r\nimport styled from \"styled-components\";\r\n// react-router-dom으로부터 withRouter를 가져와서 사용할 수 있다.\r\n// withRouter는 다른 컴포넌트를 감싸는 컴포넌트로서 라우터에 어떠한 정보를 준다.\r\n// 아래에 Header컴포넌트를 withRouter(Header)로 감싸서 사용할 수 있다.\r\nimport { Link, withRouter } from \"react-router-dom\";\r\n\r\n// 스타일 컴포넌트를 이용하면 해당 태그를 이용해서 새로운 이름의 컴포넌트를 사용자가 생성할 수 있다.\r\n// const ScHeader = styled.header``는 스타일 컴포넌트(styled)를 이용해서 header태그를 새로운 ScHeader컴포넌트로 생성한 것이다.\r\n// 주의할 점은 컴포넌트를 생성할 때는 반드시 첫 글자는 대문자로 시작해야 한다. (scHeader->오류, ScHeader로 생성해야 한다.)\r\n// 그리고 그 header태그에 줄 CSS스타일은 ``안에 적어주면 된다.\r\n// ``안에 스타일을 적을 때는 sass(scss)문법으로 적을 수 있다.\r\n// 스타일 컴포넌트를 사용할 때 기존의 HTML태그는 styled.ul 이런 식으로 사용하고 react가 가지고 있는 컴포넌트는 styled(Link) 이렇게 사용한다.\r\nconst ScHeader = styled.header`\r\n  position: fixed;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 50px;\r\n  display: flex;\r\n  padding: 0 10px;\r\n  background-color: gray;\r\n  box-shadow: 0px 1px 5px 2px rgba(0, 0, 0, 0.8);\r\n`;\r\n\r\nconst ScUl = styled.ul`\r\n  display: flex;\r\n`;\r\n\r\nconst ScLi = styled.li`\r\n  width: 70px;\r\n  text-align: center;\r\n  /* 스타일 컴포넌트는 아래의 ScLi컴포넌트가 가지고 있는 props를 가져와서 그 값의 조건에 해당하는 값을 할당해줄 수 있다. */\r\n  /* ScLi컴포넌트가 가지고 있는 current={true}를 props로는 {current:true}로 가져와서 props.current를 통해 true값을 가져올 수 있는 것이다. */\r\n  /* $안에 자바스크립트 코드를 쓸 수 있고 삼항연산자를 이용할 수 있다. */\r\n  /* 아래 코드는 props를 인자로 받아서 props안에 current값을 검사해서 있다면 true를 없다면 false를 반환해서 border-bottom의 스타일을 준다. */\r\n  border-bottom: 3px solid ${(props) => (props.current ? \"black\" : \"transparent\")};\r\n`;\r\n\r\n// 스타일 컴포넌트를 사용할 때 기존의 HTML태그는 styled.ul 이런 식으로 사용하고 react가 가지고 있는 컴포넌트는 styled(Link) 이렇게 사용한다.\r\n// Link라는 것은 HTML태그가 아니고 react에서 가지고 있는 컴포넌트이기 때문에 styled(Link)형태로 써준다.\r\nconst ScLink = styled(Link)`\r\n  height: 50px;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n`;\r\n\r\n// Header함수의 ()괄호 안에 인자에 props로 값을 받아올 수도 있고 props객체 안에 있는 바로 프로퍼티를 꺼내올 수도 있다.\r\n// 인자로 받아오는 props값은 특정 컴포넌트들로부터 전달받은 정보들이다.\r\n// 예를들어 /tv 라우트로 들어가게 되면 TV컴포넌트를 보여줄 것이고 TV컴포넌트로부터 해당 컴포넌트의 정보들을 props로 전달받게 되는 것이다.\r\n// props객체안에 location객체안에 pathname값을 바로 꺼내왔다.\r\nconst Header = ({ location: { pathname } }) => {\r\n  // console.log(pathname);\r\n\r\n  return (\r\n    <ScHeader>\r\n      {/* 스타일 컴포넌트 모듈을 사용해서 React에서 HTML태그에 CSS 스타일을 줄 때는 ul 태그 대신 위에서 변수를 만들고 그 만든 변수 List로 태그명을 바꿔준다. */}\r\n      <ScUl>\r\n        {/* 스타일 컴포넌트에서는 사용자가 만든 스타일 컴포넌트 각각에게 props를 줄 수 있다. */}\r\n        {/* 예를들면 아래와 같이 current라는 props를 주고 current의 props값에 따라 true나 false를 반환하게 할 수 있다. */}\r\n        {/* 여기서는 current가 true가 되면 ScLi에 border-bottom에 색깔을 주고 false가 되면 투명하게 처리했다. */}\r\n        {/* pathname===\"/\"을 통해 pathname이 /가 되면 해당 라우트에 들어왔기 때문에 true를 반환하게 해주는 것이다. */}\r\n        <ScLi current={pathname === \"/\"}>\r\n          {/* a태그 대신 react-router-dom에서 제공하는 Link컴포넌트를 사용했다. */}\r\n          {/* Link컴포넌트는 a태그처럼 href속성을 쓰지 않고 to속성을 사용한다. */}\r\n          <ScLink to=\"/\">Movie</ScLink>\r\n        </ScLi>\r\n        <ScLi current={pathname === \"/tv\"}>\r\n          <ScLink to=\"/tv\">TV</ScLink>\r\n        </ScLi>\r\n        <ScLi current={pathname === \"/search\"}>\r\n          <ScLink to=\"/search\">Search</ScLink>\r\n        </ScLi>\r\n      </ScUl>\r\n    </ScHeader>\r\n  );\r\n};\r\n\r\n// Header컴포넌트를 withRouter컴포넌트로 감싸줌으로서 Header컴포넌트의 인자로 props값을 받을 수 있다.\r\n// props는 리액트 라우터로부터 받은 객체로 history, location, match등의 객체가 들어있다.\r\n// withRouter덕분에 여러 다른 컴포넌트와 연결하고 props객체를 받아올 수 있는 것이다.\r\nexport default withRouter(Header);\r\n","import PropTypes from \"prop-types\";\r\nimport styled from \"styled-components\";\r\n\r\n// styled-component를 이용해서 div태그를 생성해서 그것을 변수에 담아서 리액트 컴포넌트 형태로 사용할 수 있도록 한다.\r\nconst ScContainer = styled.div`\r\n  /* :not(:last-child)를 통해 마지막 ScContainer를 제외한 나머지 것들에 스타일을 준다. */\r\n  :not(:last-child) {\r\n    margin-bottom: 50px;\r\n  }\r\n`;\r\n\r\nconst ScTitle = styled.span`\r\n  font-size: 20px;\r\n  font-weight: bold;\r\n`;\r\n\r\nconst ScGrid = styled.div`\r\n  margin-top: 20px;\r\n  display: grid;\r\n  grid-template-columns: repeat(auto-fill, 150px);\r\n`;\r\n\r\n// title과 children은 리액트 자체가 가지고 있는 예약된 props이다.\r\n// {title}과 {children}을 통해 title과 children의 데이터를 ScTitle과 ScGrid컴포넌트 안에 넣어준다.\r\n// react에서 children은 일반적으로 컴포넌트 사이의 값을 받아온다.\r\n// 여기서는 예를들면 HomePresenter.js에서 건네준 <Section>movie</Section> Section컴포넌트의 사이의 movie 값을 받는다.\r\nconst Section = ({ title, children }) => {\r\n  return (\r\n    <ScContainer>\r\n      <ScTitle>{title}</ScTitle>\r\n      <ScGrid>{children}</ScGrid>\r\n    </ScContainer>\r\n  );\r\n};\r\n\r\nSection.propTypes = {\r\n  title: PropTypes.string.isRequired,\r\n  children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.node), PropTypes.node]),\r\n};\r\n\r\nexport default Section;\r\n","import styled from \"styled-components\";\r\n\r\nconst ScContainer = styled.div`\r\n  height: 100vh;\r\n  width: 100vw;\r\n  display: flex;\r\n  justify-content: center;\r\n  font-size: 100px;\r\n  margin-top: 20px;\r\n`;\r\n\r\nconst Loader = () => (\r\n  <ScContainer>\r\n    {/* 현재에서는 생략가능하지만 예전 리액트에서는 이모지를 쓸 때 시각장애인들로 하여금 스크린을 읽을 수 있도록 아래와 같이 span태그로 감싸주고 role속성과 aria-label속성을 써줘야 했다.(필수는 아니고 경골창이 뜸) */}\r\n    {/* role에는 span안의 데이터가 img(이미지)라고 말해주는 것이고 aria-label에는 아래 이미지가 Loading이미지라고 설명해주는 것이다. */}\r\n    <span role=\"img\" aria-label=\"Loading\">\r\n      ⏰\r\n    </span>\r\n  </ScContainer>\r\n);\r\n\r\nexport default Loader;\r\n","import PropTypes from \"prop-types\";\r\nimport styled from \"styled-components\";\r\n\r\nconst ScContainer = styled.div`\r\n  width: 100vw;\r\n  display: flex;\r\n  justify-content: center;\r\n`;\r\n\r\nconst ScSpan = styled.span`\r\n  /* 스타일 컴포넌트 안에서는 $와 중괄호 안에 자바스크립트를 사용할 수 있다. */\r\n  /* ${(props) =>\r\n    props.color}를 통해 ScSpan컴포넌트가 가지고 있는 모든 props들을 가지고 온 후 그 중에서 props.color를 통해 color props를 가져와서 color={color}에서 {color}부분에 해당하는 값을 가져와서 스타일을 적용시켜준다. */\r\n  color: ${(props) => props.color};\r\n`;\r\n\r\n// Message라는 함수를 만들고 Message함수는 color와 text 매개 변수를 가지고 Presenter.js파일들에서 전달 했던 값들을 받는다.\r\n// color로는 사용자가 지정한 색깔을 받아오고 text로는 error변수를 받아와서 화면에 뿌려준다.\r\n{\r\n  /* <ScSpan color={color}></ScSpan>를 통해 매개 변수로 받은 color를  */\r\n}\r\nconst Message = ({ color, text }) => {\r\n  return (\r\n    <ScContainer>\r\n      <ScSpan color={color}>{text}</ScSpan>\r\n    </ScContainer>\r\n  );\r\n};\r\n\r\n// Message함수가 받는 props에 대한 Type를 설정해준다.\r\nMessage.propTypes = {\r\n  text: PropTypes.string.isRequired,\r\n  color: PropTypes.string.isRequired,\r\n};\r\n\r\nexport default Message;\r\n","export default __webpack_public_path__ + \"static/media/noPoster.ea2ad102.png\";","import PropTypes from \"prop-types\";\r\nimport styled from \"styled-components\";\r\nimport { Link } from \"react-router-dom\";\r\nimport noPoster from \"../assets/noPoster.png\";\r\n\r\nconst ScContainer = styled.div`\r\n  font-size: 13px;\r\n`;\r\n\r\nconst ScImage = styled.div`\r\n  /* background의 url를 지정해주기 위해 아래와 같이 props를 매개변수로 받아와서 props.imageUrl을 통해 <ScImage>컴포넌트가 가지고 있는 {imageUrl} 데이터를 가져온다. */\r\n  /* URL주소앞에 https://image.tmdb.org/t/p/w300 를 붙여주고 그 뒤에 이미지의 URL를 입력해줘야 정상적으로 가져와진다. */\r\n  /* w300대신 w400이나 w500, original을 통해 가져오려고 하는 이미지 크기를 조정할 수 있다. */\r\n  background: url(${(props) => props.imageUrl}) no-repeat center center;\r\n  background-size: cover;\r\n  height: 200px;\r\n  transition: 0.2s linear;\r\n`;\r\n\r\nconst ScRating = styled.span`\r\n  position: absolute;\r\n  bottom: 5px;\r\n  right: 5px;\r\n  opacity: 0;\r\n  transition: 0.2s linear;\r\n`;\r\n\r\nconst ScTitle = styled.span``;\r\n\r\nconst ScYear = styled.span``;\r\n\r\nconst ScImageContainer = styled.div`\r\n  margin-bottom: 5px;\r\n  position: relative;\r\n\r\n  /* ScImageContainer에 hover했을 때 ScImage와 ScRating의 스타일을 변경해준다. */\r\n  /* ${ScImage}라고 적어준 이유는 ScImage는 const로 선언된 변수이기 때문에 자바스크립트를 쓸 수 있는 $중괄호 형태로 묶어줘야 한다. */\r\n  &:hover {\r\n    ${ScImage} {\r\n      opacity: 0.3;\r\n    }\r\n    ${ScRating} {\r\n      opacity: 1;\r\n    }\r\n  }\r\n`;\r\n\r\n// Poster함수는 id, imageUrl, title, isMovie등의 파라미터를 받고 isMovie파라미터의 기본값으로는 false로 설정해줬다.\r\nconst Poster = ({ id, imageUrl, title, rating, year, isMovie = false }) => {\r\n  return (\r\n    // react-router-dom이 가지고 있는 Link컴포넌트를 통해 조건에 따라 각각의 라우터로 이동시키고 컴포넌트를 랜더한다.\r\n    // Link컴포넌트에 to속성에 라우터 URL를 지정해주고 isMovie가 true이면 /movie/${id}로 false면 /tv/${id}로 URL을 이동시키고 아래 <ScContainer>컴포넌트를 랜더한다.\r\n    // isMovie가 true라는 의미는 영화에 대한 정보가 있다는 의미니깐 /movie 라우터로 이동시키고 false라는 의미는 영화에 대한 정보가 없고 TV에 대한 정보가 있다는 의미니깐 /tv 라우터로 이동시킨다.\r\n    <Link to={isMovie ? `/movie/${id}` : `/tv/${id}`}>\r\n      <ScContainer>\r\n        <ScImageContainer>\r\n          {/* 영화나 TV 이미지가 있는지 체크해서 있으면 imageUrl props로 `https://image.tmdb.org/t/p/w300${imageUrl}`를 전달하고 없으면 require(\"../assets/noPoster.png\")를 통해 aseets폴더 아래있는 noPoster.png 이미지를 전달한다. */}\r\n          {/* 자바스크립트의 옛날 문법인 require()함수를 통해 폴더나 파일 등을 가져올 수 있다. */}\r\n          {/* require(\"../assets/noPoster.png\")뒤에 default를 붙여준 이유는 require(\"../assets/noPoster.png\")를 콘솔창에 찍어보면 Module이라는 객체를 가져오기 때문이다.  */}\r\n          {/* 우리는 Module이라는 객체 안에 있는 default프로퍼티가 가지고 있는 경로가 필요하기 때문에 .default 붙여줘서 객체안에 있는 제대로 된 데이터 경로를 가져와야 한다. */}\r\n          {/* <ScImage imageUrl={imageUrl ? `https://image.tmdb.org/t/p/w300${imageUrl}` : require(\"../assets/noPoster.png\").default}></ScImage> */}\r\n\r\n          {/* 위와 같이 require()를 통해 가져와도 되고 또 다른 방법으로는 import noPoster from \"../assets/noPoster.png\";를 통해 noPoster.png이미지를 가져와서 아래와 같이 noPoster로 넣어줄 수도 있다. */}\r\n          {/* {console.log(require(\"../assets/noPoster.png\"))} */}\r\n          <ScImage imageUrl={imageUrl ? `https://image.tmdb.org/t/p/w300${imageUrl}` : noPoster}></ScImage>\r\n          <ScRating>⭐ {rating}/10</ScRating>\r\n        </ScImageContainer>\r\n\r\n        {/* title.length를 체크해서 15보다 크면 substring(0,15)를 통해 0부터 15까지의 글자수만 전달하도록 한다. */}\r\n        <ScTitle>{title.length > 16 ? `${title.substring(0, 16)}...` : title}</ScTitle>\r\n        <ScYear>{year}</ScYear>\r\n      </ScContainer>\r\n    </Link>\r\n  );\r\n};\r\n\r\nPoster.propTypes = {\r\n  id: PropTypes.number.isRequired,\r\n  imageUrl: PropTypes.string,\r\n  title: PropTypes.string.isRequired,\r\n  rating: PropTypes.number,\r\n  year: PropTypes.string,\r\n  isMovie: PropTypes.bool,\r\n};\r\n\r\nexport default Poster;\r\n","import PropTypes from \"prop-types\";\r\nimport styled from \"styled-components\";\r\nimport Section from \"Components/Section\";\r\nimport Loader from \"Components/Loader\";\r\nimport Message from \"Components/Message\";\r\nimport Poster from \"Components/Poster\";\r\n\r\n// react-helmet모듈을 이용하면 웹 사이트의 head태그안의 내용을 수정할 수 있도록 도와준다.\r\nimport Helmet from \"react-helmet\";\r\n\r\nconst ScContainer = styled.div``;\r\n\r\nconst HomePresenter = ({ nowPlaying, upcoming, popular, error, loading }) => {\r\n  // HomePresenter함수는 만약 loading이 true면 Loader컴포넌트를, false면 ScContainer컴포넌트를 리턴한다.\r\n  return loading ? (\r\n    <Loader></Loader>\r\n  ) : (\r\n    <ScContainer>\r\n      {/* react-helmet에서 가져온 Helmet컴포넌트를 사용해서 head태그안에 내용을 넣을 수 있다. */}\r\n      {/* <Helmet><title>Netflix | Movie</title></Helmet>처럼 Helmeet컴포넌트 안에 태그를 넣어주면 head태그 안에 들어가게 된다. */}\r\n      <Helmet>\r\n        <title>Netflix | Movie</title>\r\n      </Helmet>\r\n\r\n      {/* nowPlaying && nowPlaying.length > 0 && <Section title=\"Now Playing Movies\">{nowPlaying.map((movie) => movie.title)}</Section> */}\r\n      {/* a && b && c는 a가 true이고, b가 true이고, c가 true일 때, 맨 마지막 c를 리턴한다. */}\r\n      {/* nowPlaying이 존재하는자 체크하고, nowPlaying의 배열 길이가 0보다 큰 지 체크하고, Section 컴포넌트가 존재하는지 체크한 후, Section컴포넌트를 리턴하도록 한다. */}\r\n      {/* react에서 children은 일반적으로 <Section> </Section> Section컴포넌트의 사이의 값을 전달 받는다. */}\r\n      {/* 그래서 여기서는 배열인 nowPlaying을 가져와서 map()메서드를 통해 movie를 뽑아와서 그 movie의 title을 Section.js의 children에 순차적으로 전달해준다. */}\r\n      {/* 주의할 점은 <span></span> 이렇게 태그 사이에 자바스크립트 형태의 데이터를 넣을 떄는 {}로 묶어줘야 한다. */}\r\n      {/* 그리고 각각의 span에게 key로 movie.id를 넣어준다. 왜냐하면 각각의 데이터들을 고유해야 하기 때문이다. */}\r\n      {nowPlaying && nowPlaying.length > 0 && (\r\n        <Section title=\"Now Playing Movies\">\r\n          {nowPlaying.map((movie) => (\r\n            // <span key={movie.id}>{movie.title}</span>\r\n\r\n            // Poster컴포넌트를 호출하고 Poster컴포넌트에게 각각의 props로 데이터를 넣어서 전달해준다.\r\n            // substring은 문자열을 자를 때 사용하는 메서드이다.\r\n            // movie.release_date ? movie.release_date.substring(\"0\",\"4\"):\"\"  를 통해 movie.release_date가 있으면 movie.release_date.substring(\"0\",\"4\")를 보여주고 없으면 \"\" 빈 문자열을 보낸다.\r\n            // movie.release_date.substring(\"0\",\"4\")를 통해 문자열에서 앞에서부터 0부터 3까지를 자른다.\r\n            // 또는 movie.release_date && movie.release_date.substring(\"0\",\"4\") &&를 이용해서 movie.release_date가 존재해서 true일 때 movie.release_date.substring(\"0\",\"4\")가 실행되도록 할 수 있다.\r\n            <Poster\r\n              key={movie.id}\r\n              id={movie.id}\r\n              imageUrl={movie.poster_path}\r\n              title={movie.original_title}\r\n              rating={movie.vote_average}\r\n              year={movie.release_date ? movie.release_date.substring(\"0\", \"4\") : \"\"}\r\n              isMovie={true}\r\n            ></Poster>\r\n          ))}\r\n        </Section>\r\n      )}\r\n      {upcoming && upcoming.length > 0 && (\r\n        <Section title=\"Upcoming Movies\">\r\n          {upcoming.map((movie) => (\r\n            // <span key={movie.id}>{movie.title}</span>\r\n            <Poster\r\n              key={movie.id}\r\n              id={movie.id}\r\n              imageUrl={movie.poster_path}\r\n              title={movie.original_title}\r\n              rating={movie.vote_average}\r\n              year={movie.release_date ? movie.release_date.substring(\"0\", \"4\") : \"\"}\r\n              isMovie={true}\r\n            ></Poster>\r\n          ))}\r\n        </Section>\r\n      )}\r\n      {popular && popular.length > 0 && (\r\n        <Section title=\"Popular Movies\">\r\n          {popular.map((movie) => (\r\n            // <span key={movie.id}>{movie.title}</span>\r\n            <Poster\r\n              key={movie.id}\r\n              id={movie.id}\r\n              imageUrl={movie.poster_path}\r\n              title={movie.original_title}\r\n              rating={movie.vote_average}\r\n              year={movie.release_date ? movie.release_date.substring(\"0\", \"4\") : \"\"}\r\n              isMovie={true}\r\n            ></Poster>\r\n          ))}\r\n        </Section>\r\n      )}\r\n\r\n      {/* 만약 error가 존재하면 <Message>컴포넌트에 text props로는 error를, color props로는 사용자가 설정할 색깔을 전달해준다. */}\r\n      {/* 여기서는 color로는 red를 text로는 error변수를 전달해준 것이다. */}\r\n      {error && <Message color=\"red\" text={error}></Message>}\r\n    </ScContainer>\r\n  );\r\n};\r\n\r\nHomePresenter.propTypes = {\r\n  nowPlaying: PropTypes.array,\r\n  upcoming: PropTypes.array,\r\n  popular: PropTypes.array,\r\n  error: PropTypes.string,\r\n  loading: PropTypes.bool.isRequired,\r\n};\r\n\r\nexport default HomePresenter;\r\n","import axios from \"axios\";\r\n\r\n// axios가 가지고 있는 create()함수를 이용해서 함수 내부에 객체형태로 axios의 초기설정을 해줄 수 있다.\r\n// baseURL에는 API를 요청하는 기본 URL을, params에는 URL에 들어가는 api_key와 language에 대한 정보를 객체형태로 적어준다.\r\n// params 객체 안에 입력한 값들은 baseURL의 URL주소 뒤에 붙어서 들어간다.\r\n// (ex: https://api.themoviedb.org/3/tv/popular?api_key=d20d691c4dcca268fa8e0c655d698616&language=en-US)\r\n// 아래와 같이 설정해주게 되면 이제 우리가 API를 요청할 때 아래에 설정한 값들을 가지고 요청하게 된다.\r\nconst api = axios.create({\r\n  baseURL: \"https://api.themoviedb.org/3/\",\r\n  params: {\r\n    api_key: \"d20d691c4dcca268fa8e0c655d698616\",\r\n    language: \"en-US\",\r\n  },\r\n});\r\n\r\n// 위에 설정을 해줬다면 이젠 get()함수를 통해 get방식으로 해당 주소로 API를 요청하면 된다.\r\n// 주의할 점은 /tv/popular가 아닌 tv/popular로 써줘야 한다.\r\n// 만약 /로 시작하게 되면 그것은 절대경로를 의미하고 그렇다면 위에 baseURL의 URL을 덮어씌워버리기 때문이다.\r\n// 우리는 상대경로를 써서 https://api.themoviedb.org/3/tv/popular로 요청해야 한다.\r\n// api.get(\"tv/popular\");\r\n\r\n// moviesApi와 tvApi객체를 생성해서 Movie와 TV각각에 해당하는 API를 안에 담아서 힌 번에 관리할 수 있도록 한다.\r\n// moviesApi와 tvApi 객체안에 프로퍼티를 만들고 각각의 프로퍼티는 api.get()을 통해 URL주소로 요청하고 요청한 결과 값을 반환해준다.\r\nexport const moviesApi = {\r\n  nowPlaying: () => api.get(\"movie/now_playing\"),\r\n  upcoming: () => api.get(\"movie/upcoming\"),\r\n  popular: () => api.get(\"movie/popular\"),\r\n\r\n  // movieDetail의 함수는 id값을 받고  그 id를 이용해서 api를 요청한다.\r\n  // api.get(`movie/${id}`,{})에서 두 번째 인자로 {}객체를 쓰고 그 안에 추가적인 params를 써줄 수 있다.\r\n  // 이런 방식을 통해 라우터, 파라미터들을 개별적으로 설정할 수 있다.\r\n  // 그렇게되면 movie/${id}/에서 append_to_response=videos가 추가적으로 붙게된다.\r\n  // 또한 append_to_response으로 video나 image등을 params로 같이 전달하게 되면 결과 값으로 id, key(유튜브 예고편의 URL주소), 이름, site, size 등의 정보를 준다.\r\n  movieDetail: (id) =>\r\n    api.get(`movie/${id}`, {\r\n      params: {\r\n        append_to_response: \"videos\",\r\n      },\r\n    }),\r\n\r\n  // search함수는 term값을 받고 term을 이용해서 검색한다.\r\n  // 위에 movieDetail은 append_to_response에 값을 넣어 전달했지만 아래 search는 params로 query안에 값을 전달해야 한다.\r\n  // append_to_response, query등의 이름은 변경 불가하다.\r\n  search: (term) =>\r\n    api.get(\"search/movie\", {\r\n      params: {\r\n        query: term,\r\n\r\n        // 만약 인자 term에 문자열+빈칸 형태로 값이 오게 되면 (ex: hello Cody! => hello%20Cody%21) %20 이런식으로 나오게 된다.\r\n        // 예를들어 사용자가 @를 입력하면 URL에 인코딩되 변환되서 들어가야 한다. 왜냐하면 term은 string으로 되어야 하기 때문이다.\r\n        // 그래서 우리는 이것을 처리하는 부분이 필요하다. 그 때 사용하는 것이 encodeURIComponent이다.\r\n        // 즉 어떤 term값을 넘기든 encodeURIComponent()함수를 통해 값을 인코딩하고 그 문자열을 검색한다.\r\n        // axios에서 기본적으로 encodeURIComponent을 지원해주기 때문에 굳이 쓰지 않아도 됨\r\n        // query: encodeURIComponent(term),\r\n      },\r\n    }),\r\n};\r\n\r\nexport const tvApi = {\r\n  topRated: () => api.get(\"tv/top_rated\"),\r\n  popular: () => api.get(\"tv/popular\"),\r\n  airingToday: () => api.get(\"tv/airing_today\"),\r\n  tvDetail: (id) =>\r\n    api.get(`tv/${id}`, {\r\n      params: {\r\n        append_to_response: \"videos\",\r\n      },\r\n    }),\r\n  search: (term) =>\r\n    api.get(\"search/tv\", {\r\n      params: {\r\n        query: term,\r\n      },\r\n    }),\r\n};\r\n\r\nexport default api;\r\n","// 작은 프로젝트가 아닌 조금 규모가 있는 프로젝트를 할 때는 이것처럼 Home폴더를 따로 만들고 Home폴더안에 index.js와 HomeContainer.js등등의 파일을 모아놓고 관리하는 것이 좋다.\r\n// 이와 같은 방법을 컨테이너 프리젠터 패턴이라고 부른다.\r\n// 그리고 아래와 같이 3개의 파일로 나눠서 관리한다. (리액트가 index.js를 가장 기본적으로 읽기 때문에 index.js가 필요함)\r\n// 컨테이너(HomeContainer.js)는 data를 가지고, state값을 가지고, api를 불러와서 모든 로직을 처리한다. (데이터 담당)\r\n// 프리젠터(HomePresenter.js)는 컨테이너가 처리한 데이터들을 보여주는 역할을 하는 함수형 컴포넌트이다. (state, api, 클래스를 다루지는 않는다.) (스타일 담당)\r\nimport HomeContainer from \"./HomeContainer\";\r\n\r\nexport default HomeContainer;\r\n","import React from \"react\";\r\nimport HomePresenter from \"./HomePresenter\";\r\nimport { moviesApi } from \"api\";\r\n\r\nclass HomeContainer extends React.Component {\r\n  // HomeContainer클래스를 생성하고 기본적인 state를 정의해줬다.\r\n  state = {\r\n    nowPlaying: null,\r\n    upcoming: null,\r\n    popular: null,\r\n    error: null,\r\n    loading: true,\r\n  };\r\n\r\n  // componentWillMount는 컴포넌트가 생성된 후 실행되는 함수이다.\r\n  // try,catch,finally를 통해 try문을 실행하고 finally문을 실행하거나 try문에서 오류가 나면 catch문을 실행하고 finally문을 실행한다.\r\n  async componentDidMount() {\r\n    // api.js에서 만든 moviesApi를 가져와서 거기안에 있는 nowPlaying함수를 실행한다.\r\n    // nowPlaying함수는 api.get(\"movie/now_playing\")를 하고 API 정보를 가져온다.\r\n    try {\r\n      const {\r\n        data: { results: nowPlaying },\r\n      } = await moviesApi.nowPlaying();\r\n      // console.log(nowPlaying);\r\n\r\n      const {\r\n        data: { results: upcoming },\r\n      } = await moviesApi.upcoming();\r\n      // console.log(upcoming);\r\n\r\n      const {\r\n        data: { results: popular },\r\n      } = await moviesApi.popular();\r\n      // console.log(popular);\r\n\r\n      // throw Error()를 통해 의도적으로 에러를 던져서 catch문이 실행되도록 테스트해볼 수 있다.\r\n      // throw Error();\r\n\r\n      // 여기서 주의할 점은 아래에 console.log(this.state)가 3번 찍히게 된다.\r\n      // 그 이유는 this.setState()함수가 실행이 되면! 리액트는 render()함수를 다시 실행하기 때문이다.\r\n      // 그래서 최초의 1번째, 컴포넌트가 생성된 후 try문을 실행하면서 2번째, finally문을 실행하면서 3번째 실행이 되는 것이다.\r\n      // 단 리액트는 모든 것을 리 랜더링하는 것이 아니라 바뀐 부분만 찾아서 리 랜더링한다.\r\n      // eslint-disable-next-line no-unreachable\r\n      this.setState({\r\n        nowPlaying,\r\n        upcoming,\r\n        popular,\r\n      });\r\n    } catch (error) {\r\n      this.setState({\r\n        error: \"Can't find Movie Information.\",\r\n      });\r\n    } finally {\r\n      this.setState({\r\n        loading: false,\r\n      });\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const { nowPlaying, upcoming, popular, error, loading } = this.state;\r\n    // console.log(this.state);\r\n\r\n    return <HomePresenter nowPlaying={nowPlaying} upcoming={upcoming} popular={popular} error={error} loading={loading} />;\r\n  }\r\n}\r\n\r\nexport default HomeContainer;\r\n","import PropTypes from \"prop-types\";\r\nimport styled from \"styled-components\";\r\nimport Section from \"Components/Section\";\r\nimport Loader from \"Components/Loader\";\r\nimport Message from \"Components/Message\";\r\nimport Poster from \"Components/Poster\";\r\nimport Helmet from \"react-helmet\";\r\n\r\nconst ScContainer = styled.div`\r\n  padding: 0 10px;\r\n`;\r\n\r\n// TVContainer로부터 받아온 객체를 함수의 파라미터로 받는다.\r\nconst TVPresenter = ({ topRated, popular, airingToday, error, loading }) => {\r\n  // loading을 체크해서 loading이 true일 때는 Loader컴포넌트를, false면 ScContainer컴포넌트를 리턴한다.\r\n  // ScContainer컴포넌트는 Section컴포넌트를 가지고 있고 Section컴포넌트로 title에 값을 넘겨주고 children에는 <Section></Section>사이의 값을 데이터로 넘겨준다.\r\n  return loading ? (\r\n    <Loader></Loader>\r\n  ) : (\r\n    <ScContainer>\r\n      <Helmet>\r\n        <title>Netflix | TV</title>\r\n      </Helmet>\r\n      {topRated && topRated.length > 0 && (\r\n        <Section title=\"Top Rated TV\">\r\n          {topRated.map((tv) => (\r\n            // TVPresenter는 Poster컴포넌트에게 각각의 tv에 대한 데이터를 props로 넘겨준다.\r\n            <Poster\r\n              key={tv.id}\r\n              id={tv.id}\r\n              imageUrl={tv.poster_path}\r\n              title={tv.original_name}\r\n              rating={tv.vote_average}\r\n              year={tv.first_air_date ? tv.first_air_date.substring(\"0\", \"4\") : \"\"}\r\n              isMovie={false}\r\n            ></Poster>\r\n          ))}\r\n        </Section>\r\n      )}\r\n      {popular && popular.length > 0 && (\r\n        <Section title=\"Popular TV\">\r\n          {popular.map((tv) => (\r\n            <Poster\r\n              key={tv.id}\r\n              id={tv.id}\r\n              imageUrl={tv.poster_path}\r\n              title={tv.original_name}\r\n              rating={tv.vote_average}\r\n              year={tv.first_air_date ? tv.first_air_date.substring(\"0\", \"4\") : \"\"}\r\n              isMovie={false}\r\n            ></Poster>\r\n          ))}\r\n        </Section>\r\n      )}\r\n      {airingToday && airingToday.length > 0 && (\r\n        <Section title=\"Airing Today TV\">\r\n          {airingToday.map((tv) => (\r\n            <Poster\r\n              key={tv.id}\r\n              id={tv.id}\r\n              imageUrl={tv.poster_path}\r\n              title={tv.original_name}\r\n              rating={tv.vote_average}\r\n              year={tv.first_air_date ? tv.first_air_date.substring(\"0\", \"4\") : \"\"}\r\n              isMovie={false}\r\n            ></Poster>\r\n          ))}\r\n        </Section>\r\n      )}\r\n      {error && <Message color=\"blue\" text={error}></Message>}\r\n    </ScContainer>\r\n  );\r\n};\r\n\r\n// PropTypes를 통해 받아온 props들의 타입들을 검사한다.\r\nTVPresenter.propTypes = {\r\n  topRated: PropTypes.array,\r\n  popular: PropTypes.array,\r\n  airingToday: PropTypes.array,\r\n  error: PropTypes.string,\r\n  loading: PropTypes.bool.isRequired,\r\n};\r\n\r\nexport default TVPresenter;\r\n","import TVContainer from \"./TVContainer\";\r\n\r\nexport default TVContainer;\r\n","import React from \"react\";\r\nimport TYPresenter from \"./TVPresenter\";\r\nimport { tvApi } from \"api\";\r\n\r\nclass TVContainer extends React.Component {\r\n  state = {\r\n    topRated: null,\r\n    popular: null,\r\n    airingToday: null,\r\n    error: null,\r\n    loading: true,\r\n  };\r\n\r\n  // componentWillMount를 통해 컴포넌트가 생성되고 난 후 실행시킬 코드를 안에 넣어준다.\r\n  async componentDidMount() {\r\n    // try,catch,finally처리를 해주고 tvApi에서 topRated()함수를 실행해서 api를 통해 데이터를 가져오도록 한다.\r\n    try {\r\n      const {\r\n        data: { results: topRated },\r\n      } = await tvApi.topRated();\r\n      const {\r\n        data: { results: popular },\r\n      } = await tvApi.popular();\r\n      const {\r\n        data: { results: airingToday },\r\n      } = await tvApi.airingToday();\r\n\r\n      // console.log(topRated, popular, airingToday);\r\n\r\n      // throw Error();\r\n\r\n      this.setState({\r\n        topRated,\r\n        popular,\r\n        airingToday,\r\n      });\r\n    } catch {\r\n      this.setState({\r\n        error: \"Can't find TV Information.\",\r\n      });\r\n    } finally {\r\n      this.setState({\r\n        loading: false,\r\n      });\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const { topRated, popular, airingToday, error, loading } = this.state;\r\n    // console.log(this.state);\r\n\r\n    return <TYPresenter topRated={topRated} popular={popular} airingToday={airingToday} error={error} loading={loading} />;\r\n  }\r\n}\r\n\r\nexport default TVContainer;\r\n","import PropTypes from \"prop-types\";\r\nimport styled from \"styled-components\";\r\nimport Section from \"Components/Section\";\r\nimport Loader from \"Components/Loader\";\r\nimport Message from \"Components/Message\";\r\nimport Poster from \"Components/Poster\";\r\nimport Helmet from \"react-helmet\";\r\n\r\nconst ScContainer = styled.div`\r\n  padding: 0 20px;\r\n`;\r\n\r\nconst ScForm = styled.form`\r\n  margin-bottom: 20px;\r\n`;\r\n\r\nconst ScInput = styled.input`\r\n  /* all: unset;은 모든 스타일 속성을 초기화 시켜버린다. */\r\n  /* all: unset; */\r\n  font-size: 25px;\r\n`;\r\n\r\nconst SearchPresenter = ({ movieResults, tvResults, searchTerm, error, loading, handleSubmit, updateSearchTerm }) => {\r\n  console.log(\"movieResults\", movieResults);\r\n  console.log(\"tvResults\", tvResults);\r\n\r\n  return (\r\n    <ScContainer>\r\n      <Helmet>\r\n        <title>Netflix | Search</title>\r\n      </Helmet>\r\n\r\n      {/* onSubmit속성을 통해 Submit이벤트가 발생했을 때 handleSubmit함수를 실행하고 onChange속성을 통해 input에 변화가 생겼을 때 updateSearchTerm함수를 실행한다. */}\r\n      <ScForm onSubmit={handleSubmit} onChange={updateSearchTerm}>\r\n        {/* form태그안에는 input태그가 있고 input태그의 value로는 state안에 있는 searchTerm을 가져온다. */}\r\n        <ScInput placeholder=\"Search Movies or TV...\" value={searchTerm}></ScInput>\r\n      </ScForm>\r\n      {loading ? (\r\n        <Loader></Loader>\r\n      ) : (\r\n        <>\r\n          {movieResults && movieResults.length > 0 && (\r\n            <Section title=\"Movie Results\">\r\n              {movieResults.map((movie) => (\r\n                // <span key={movie.id}>{movie.title}</span>\r\n\r\n                <Poster\r\n                  key={movie.id}\r\n                  id={movie.id}\r\n                  imageUrl={movie.poster_path}\r\n                  title={movie.original_title}\r\n                  rating={movie.vote_average}\r\n                  year={movie.release_date ? movie.release_date.substring(\"0\", \"4\") : \"\"}\r\n                  isMovie={true}\r\n                ></Poster>\r\n              ))}\r\n            </Section>\r\n          )}\r\n          {tvResults && tvResults.length > 0 && (\r\n            <Section title=\"TV Results\">\r\n              {tvResults.map((tv) => (\r\n                // <span key={tv.id}>{tv.name}</span>\r\n\r\n                <Poster\r\n                  key={tv.id}\r\n                  id={tv.id}\r\n                  imageUrl={tv.poster_path}\r\n                  title={tv.original_name}\r\n                  rating={tv.vote_average}\r\n                  year={tv.first_air_date ? tv.first_air_date.substring(\"0\", \"4\") : \"\"}\r\n                  isMovie={false}\r\n                ></Poster>\r\n              ))}\r\n            </Section>\r\n          )}\r\n        </>\r\n      )}\r\n      {error && <Message color=\"green\" text={error}></Message>}\r\n\r\n      {/* Search페이지에서 영화나 TV를 검색했을 때 만약 없는 영화나 TV라면 <Message>컴포넌트를 랜더하도록 한다. */}\r\n      {/* 검색했을 때 movieResults가 true이고 tvResults가 true이고, movieResults의 길이가 0이고 tvResults의 길이가 0이면 <Message>컴포넌트를 랜더한다. */}\r\n      {/* 검색했을 때 검색한 것이 영화나 TV에 없다면 movieResults와 tvResults는 빈 배열이 반환하게 되지만, 빈 배열 또한 Boolean([])으로 확인해보면 true를 반환하므로 아래 코드가 작동하는 것이다. */}\r\n      {/* 그래서 만약 검색한 것이 없다면 <Message>컴포넌트의 text props로 \"Nothing Found\"를 전달해준다. */}\r\n      {movieResults && tvResults && movieResults.length === 0 && tvResults.length === 0 && <Message color=\"red\" text=\"Nothing Found\"></Message>}\r\n    </ScContainer>\r\n  );\r\n};\r\n\r\nSearchPresenter.propTypes = {\r\n  movieResults: PropTypes.array,\r\n  tvResults: PropTypes.array,\r\n  searchTerm: PropTypes.string,\r\n  error: PropTypes.string,\r\n  loading: PropTypes.bool.isRequired,\r\n  handleSubmit: PropTypes.func.isRequired,\r\n  updateSearchTerm: PropTypes.func.isRequired,\r\n};\r\n\r\nexport default SearchPresenter;\r\n","import SearchContainer from \"./SearchContainer\";\r\n\r\nexport default SearchContainer;\r\n","import React from \"react\";\r\nimport SearchPresenter from \"./SearchPresenter\";\r\nimport { moviesApi, tvApi } from \"api\";\r\n\r\nclass SearchContainer extends React.Component {\r\n  state = {\r\n    movieResults: null,\r\n    tvResults: null,\r\n    searchTerm: \"\",\r\n    error: null,\r\n    lodaing: false,\r\n  };\r\n\r\n  // componentDidMount() {\r\n  //   this.handleSubmit();\r\n  // }\r\n\r\n  // handleSubmit은 form에서 텍스트를 입력하고 엔터를 눌렀을 때 실행되는 함수이다.\r\n  handleSubmit = (event) => {\r\n    event.preventDefault();\r\n\r\n    // handleSubmit함수는 state안에 있는 searchTerm을 가져와서 확인하고 그것이 빈 값이 아니면 searchByTerm함수를 실행한다.\r\n    const { searchTerm } = this.state;\r\n\r\n    if (searchTerm !== \"\") {\r\n      this.searchByTerm();\r\n    }\r\n  };\r\n\r\n  // updateSearchTerm 함수는 사용자가 input에서 입력한 값을 value로 받아온다.\r\n  // value로 받아와서 setState함수를 통해 searchTerm에 넣는다.\r\n  updateSearchTerm = (event) => {\r\n    const {\r\n      target: { value },\r\n    } = event;\r\n    // console.log(value);\r\n\r\n    this.setState({\r\n      searchTerm: value,\r\n    });\r\n  };\r\n\r\n  // searchByTerm함수는 state안에 있는 searchTerm을 가져와서 각각 moviesApi.search()와 tvApi.search()의 인자로 전달해준다.\r\n  // 그래서 영화와 tv데이터에서 사용자가 검색한 searchTerm에 해당하는 데이터들을 가져와준다.\r\n  // 그리고 그 데이터들을 state의 movieResults와 tvResults에 넣는다.\r\n  searchByTerm = async () => {\r\n    const { searchTerm } = this.state;\r\n    this.setState({ loading: true });\r\n\r\n    try {\r\n      const {\r\n        data: { results: movieResults },\r\n      } = await moviesApi.search(searchTerm);\r\n      const {\r\n        data: { results: tvResults },\r\n      } = await tvApi.search(searchTerm);\r\n      // console.log(movieResults, tvResults);\r\n\r\n      // throw Error();\r\n\r\n      this.setState({\r\n        movieResults,\r\n        tvResults,\r\n      });\r\n    } catch {\r\n      this.setState({\r\n        error: \"Can't fint Results.\",\r\n      });\r\n    } finally {\r\n      this.setState({\r\n        loading: false,\r\n      });\r\n    }\r\n  };\r\n\r\n  render() {\r\n    const { movieResults, tvResults, searchTerm, error, loading } = this.state;\r\n    // console.log(this.state);\r\n\r\n    return (\r\n      <SearchPresenter\r\n        movieResults={movieResults}\r\n        tvResults={tvResults}\r\n        searchTerm={searchTerm}\r\n        error={error}\r\n        loading={loading}\r\n        handleSubmit={this.handleSubmit}\r\n        updateSearchTerm={this.updateSearchTerm}\r\n      />\r\n    );\r\n  }\r\n}\r\n\r\nexport default SearchContainer;\r\n","import PropTypes from \"prop-types\";\r\nimport styled from \"styled-components\";\r\nimport Loader from \"Components/Loader\";\r\nimport Message from \"Components/Message\";\r\nimport noPoster from \"../../assets/noPoster.png\";\r\nimport Helmet from \"react-helmet\";\r\n\r\nconst ScContainer = styled.div`\r\n  height: calc(100vh - 50px);\r\n  width: 100%;\r\n  position: relative;\r\n`;\r\n\r\nconst ScBackdrop = styled.div`\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  background: url(${(props) => props.imageUrl}) no-repeat center center;\r\n  background-size: cover;\r\n  filter: blur(3px);\r\n  opacity: 0.5;\r\n`;\r\n\r\nconst ScContent = styled.div`\r\n  display: flex;\r\n  justify-content: flex-start;\r\n  align-items: center;\r\n  width: 100%;\r\n  height: 100%;\r\n  position: relative;\r\n  z-index: 1;\r\n`;\r\n\r\nconst ScCover = styled.div`\r\n  width: 20%;\r\n  height: 80%;\r\n  background: url(${(props) => props.imageUrl}) no-repeat center center;\r\n  background-size: cover;\r\n`;\r\n\r\nconst ScData = styled.div`\r\n  width: 70%;\r\n  margin-left: 10px;\r\n`;\r\n\r\nconst ScTitle = styled.h1`\r\n  font-size: 30px;\r\n  margin-bottom: 20px;\r\n`;\r\n\r\nconst ScItemContainer = styled.div``;\r\n\r\nconst ScItem = styled.span``;\r\n\r\nconst ScDivider = styled.span``;\r\n\r\nconst ScOverview = styled.p`\r\n  margin-top: 30px;\r\n  line-height: 1.5;\r\n`;\r\n\r\nconst DetailPresenter = ({ result, error, loading = true }) => {\r\n  // console.log(\"result\", result);\r\n  // console.log(\"loading\", loading);\r\n\r\n  return loading ? (\r\n    <Loader></Loader>\r\n  ) : error ? (\r\n    <Message></Message>\r\n  ) : (\r\n    <ScContainer>\r\n      <Helmet>\r\n        <title>Netflix | {result.original_title}</title>\r\n      </Helmet>\r\n\r\n      {/* {console.log(result.backdrop_path)} */}\r\n      {/* ScBackdrop컴포넌트는 result안에 있는 backdrop_path를 가져오고 만약 있으면 https://image.tmdb.org/t/p/original${result.backdrop_path}를, 없으면 noPoster변수를 imageUrl props로 전달한다. */}\r\n      <ScBackdrop imageUrl={result.backdrop_path ? `https://image.tmdb.org/t/p/original${result.backdrop_path}` : noPoster}></ScBackdrop>\r\n      <ScContent>\r\n        <ScCover imageUrl={result.poster_path ? `https://image.tmdb.org/t/p/original${result.poster_path}` : noPoster}></ScCover>\r\n        <ScData>\r\n          <ScTitle>{result.original_title ? result.original_title : result.original_name}</ScTitle>\r\n          <ScItemContainer>\r\n            <ScItem>{result.release_date ? result.release_date.substring(0, 4) : result.first_air_date.substring(0, 4)}</ScItem>\r\n            <ScDivider>▪</ScDivider>\r\n            <ScItem>{result.runtime ? result.runtime : result.episode_run_time}분</ScItem>\r\n            <ScDivider>▪</ScDivider>\r\n            {/* {조건 ? 참: 거짓}과 아래 {조건 && 구문}의 차이점은 위는 조건이 true이면 참 또는 거짓을 실행하지만 아래는 조건이 true이면 && 뒷 구문을 실행한다. */}\r\n            {/* 만약 result.genres가 존재해서 true면 result.genres.map()함수를 실행한다. */}\r\n            {/* result.genres.map()함수는 매개변수로 genres와 index를 받고 index와 result.genres배열의 길이가 같아지면 genre.name를 출력하고 그렇지 않을 때는 genre.name /을 출력한다. */}\r\n            {/* Family / Drama 이런식으로 맨 마지막 장르 Drama에서는 /가 붙지 않게 하기 위해서 아래와 같이 코드를 짰다. */}\r\n            <ScItem>{result.genres && result.genres.map((genre, index) => (index === result.genres.length - 1 ? genre.name : `${genre.name} / `))}</ScItem>\r\n            <ScDivider>▪</ScDivider>\r\n            <ScItem>⭐{result.vote_average && result.vote_average}/10</ScItem>\r\n          </ScItemContainer>\r\n          <ScOverview>{result.overview && result.overview}</ScOverview>\r\n        </ScData>\r\n      </ScContent>\r\n    </ScContainer>\r\n  );\r\n};\r\n\r\nDetailPresenter.propTypes = {\r\n  result: PropTypes.object,\r\n  error: PropTypes.string,\r\n  loading: PropTypes.bool.isRequired,\r\n};\r\n\r\nexport default DetailPresenter;\r\n","import DetailContainer from \"./DetailContainer\";\r\n\r\nexport default DetailContainer;\r\n","import { moviesApi, tvApi } from \"api\";\r\nimport React from \"react\";\r\nimport DetailPresenter from \"./DetailPresenter\";\r\n\r\nclass DetailContainer extends React.Component {\r\n  // constructor함수안에 state를 넣어서 관리할 수도 있다.\r\n  // constructor함수안에 들어가게 되면 state앞에 this를 붙여줘야 한다.\r\n  constructor(props) {\r\n    super(props);\r\n    const {\r\n      location: { pathname },\r\n    } = props;\r\n\r\n    // includes()메서드를 이용해서 ()괄호안에 값이 포함되는지를 검사한다.\r\n    // 포함된다면 true, 포함되지 않았다면 false를 반환한다.\r\n    // isMovie를 state안에 넣어서 관리할 수도 있고, state밖에서 this.isMovie=pathname.includes(\"/movie/\")를 통해 생성해서 관리할 수도 있다.\r\n    this.state = {\r\n      result: null,\r\n      error: null,\r\n      lodaing: true,\r\n      isMovie: pathname.includes(\"/movie/\"),\r\n    };\r\n  }\r\n\r\n  async componentDidMount() {\r\n    // react-router-dom은 기본적으로 각각의 라우트들에게 props에 대한 정보를 준다.\r\n    // this.props안에 match객체안에 params 프로퍼티에는 /movie/:id 에서 :id에 들어가있는 값이 담겨져 있다.\r\n    // 리다이렉트 기능을 가지고 있는 push메서드를 사용하기 위해 history객체에서 가져왔다.\r\n    const {\r\n      match: {\r\n        params: { id },\r\n      },\r\n      history: { push },\r\n      location: { pathname },\r\n    } = this.props;\r\n    // console.log(this.props);\r\n\r\n    // parseInt()함수를 통해 id를 숫자로 변환한다.\r\n    const parsedId = parseInt(id);\r\n\r\n    // isNaN()함수는 ()괄호안의 인자가 NaN인지 아닌지를 판별해서 NaN이라면 true를 아니라면 false를 반환한다.\r\n    // 만약 parsedId가 숫자가 아닌 문자여서 NaN이라면 push(\"/\")함수를 통해 / 경로로 리다이렉트 시켜버린다.\r\n    if (isNaN(parsedId)) {\r\n      push(\"/\");\r\n\r\n      // 주의! push()를 해준 후 return을 해줘야 함수가 종료되서 아래 콘솔로그 코드가 실행되지 않는다.\r\n      return;\r\n    }\r\n    // console.log(\"abc\");\r\n\r\n    let result = null;\r\n    const { isMovie } = this.state;\r\n\r\n    // isMovie는 url주소에 /movie/가 존재하는지 확인하는 변수로 url주소에 /movie/가 존재하면 true를 반환하고 아니라면 false를 반환한다.\r\n    // 그래서 만약 /movie/면 true를 /tv/면 false를 반환한다.\r\n    // isMovie가 true라면 try문안에 if문을 실행해서 moviesApi.movieDetail()를 통해 /movie/123같은 주소로 api.get()를 실행한다.\r\n    try {\r\n      if (isMovie) {\r\n        // const request = await moviesApi.movieDetail(parsedId);\r\n        // result = request.data;\r\n\r\n        // 위의 코드를 ES6문법에 따라 아래와 같이도 쓸 수 있다.\r\n        // 전체에 ()괄호를 쳐주고 {}를 통해 data프로퍼티를 바로 뽑아올 수 있다.\r\n        // 전체에 ()괄호를 쳐주게 되면 바로 객체 안으로 들어가게 되고 거기에 data프로퍼티를 뽑아와서 그 data프로퍼티의 이름을 result로 변경한 것이다.\r\n        // ()괄호를 쳐주게 되면 ({data:  result} = await moviesApi.movieDetail(parsedId)); 는 const = {data : result}와 같은 의미이다.\r\n        ({ data: result } = await moviesApi.movieDetail(parsedId));\r\n      } else {\r\n        // const request = await tvApi.tvDetail(parsedId);\r\n        // result = request.data;\r\n\r\n        ({ data: result } = await tvApi.tvDetail(parsedId));\r\n      }\r\n      // console.log(\"result\", result);\r\n    } catch (error) {\r\n      this.setState({ error: \"Can't find anything.\" });\r\n    } finally {\r\n      this.setState({ loading: false, result });\r\n    }\r\n  }\r\n\r\n  render() {\r\n    // console.log(this.props);\r\n\r\n    const { result, error, loading } = this.state;\r\n    // console.log(this.state);\r\n\r\n    return <DetailPresenter result={result} error={error} loading={loading} />;\r\n  }\r\n}\r\n\r\nexport default DetailContainer;\r\n","import React from \"react\";\r\n// HashRouter as Router: HashRouter를 react-router-dom으로부터 가져와서 이름을 바꿔 Router로 사용하도록 한다.\r\nimport { HashRouter, BrowserRouter as Router, Route, Redirect, Switch } from \"react-router-dom\";\r\nimport Header from \"Components/Header\";\r\nimport Home from \"Routes/Home\";\r\nimport TV from \"Routes/TV\";\r\nimport Search from \"Routes/Search\";\r\nimport Detail from \"Routes/Detail\";\r\n\r\n// HashRouter는 약간 앱처럼 보여주면서 사용자 페이지의 Hash를 사용한다. (URL에 #가 붙는다.)\r\n// BrowserRouter는 웹 사이트처럼 보여주면서 HTML history API를 사용한다. (URL에 #가 붙지 않고 일반적인 웹사이트처럼 보인다.)\r\n\r\n// eslint-disable-next-line import/no-anonymous-default-export\r\nexport default () => {\r\n  return (\r\n    // Route는 리액트에서 라우트로 페이지를 만들고 이동할 수 있다.\r\n    // Route는 Router안에 감싸져 있어야 한다.\r\n    // path는 URL을 지정할 수 있고 component에는 해당 URL에 왔을 때 보여줄 컴포넌트를 지정한다.\r\n    <Router>\r\n      <Header></Header>\r\n\r\n      {/* Switch컴포넌트는 리액트 라우터가 오직 하나의 Route만 랜더하게 해준다. */}\r\n      {/* 다시말해, /tv나 /tv/abc 모두 하나의 라우트만 랜더해준다. (다른 라우트를 랜더해주지 않는다.) */}\r\n      {/* 그래서 다른 라우트를 랜더해주기 위해서는 /tv에 exact속성을 넣어줘서 정확히 /tv인 경우에만 TV컴포넌트를 랜더해서 보여주도록 한다. */}\r\n      <Switch>\r\n        <Route path=\"/\" exact component={Home}></Route>\r\n        <Route path=\"/tv\" exact component={TV}></Route>\r\n\r\n        {/* 아래와 같이 component가 아닌 render를 통해서도 함수를 실행하고 리턴해서 보여줄 수 있다. */}\r\n        {/* <Route path=\"/tv/abc\" render={() => <h1>TV abc</h1>}></Route> */}\r\n        <Route path=\"/search\" component={Search}></Route>\r\n\r\n        {/* id를 받아서 그 id에 해당하는 주소로 갔을 때 Detail컴포넌트를 실행한다. */}\r\n        <Route path=\"/movie/:id\" component={Detail}></Route>\r\n        <Route path=\"/tv/:id\" component={Detail}></Route>\r\n\r\n        {/* Redirect컴포넌트는 path경로에 들어왔을 때 일치하는 Route 컴포넌트를 찾고, 일치하는 것이 없다면 / URL로 리다이렉트 시켜버린다. */}\r\n        {/* from=\"*\"는 모든 페이지를 다 리다이렉트 시킬 수 있다는 의미이고, to는 리다이렉트가 발생했을 때 리다이렉트 시켜버리는 URL을 의미한다. */}\r\n        <Redirect from=\"*\" to=\"/\"></Redirect>\r\n      </Switch>\r\n    </Router>\r\n  );\r\n};\r\n","// styled-components는 Local로 동작하기 때문에 Global한 css를 만들어 주기 위해 GlobalStyles.js 생성했다.\r\n// 일반적으로 스타일 컴포넌트는 각기 다른 컴포넌트들에게 스타일의 영향을 주지 않기 위해서 Local로 동작하지만 글로벌한 스타일이 필요할 때는(reset.css같은 경우) 아래와 같이 만들어줄 수 있다.\r\n// 이 때 사용하는 것이 styled-components로부터 가져온 createGlobalStyle함수이다.\r\n// createGlobalStyle함수를 사용하면 Local설정을 Global설정으로 적용할 수 있게 해준다.\r\nimport { createGlobalStyle } from \"styled-components\";\r\n\r\n// styled-reset를 이용해서 css를 초기화 시킬 수 있다.\r\n// reset은 아래처럼 createGlobalStyle``안에 넣어주고 ${reset}을 통해 적용할 수 있다.\r\nimport reset from \"styled-reset\";\r\n\r\nconst globalStyles = createGlobalStyle`\r\n  ${reset};\r\n  *{\r\n    box-sizing: border-box;\r\n  }\r\n  body{\r\n    background-color: lightgray;\r\n    padding-top: 50px;\r\n  }\r\n  a{\r\n    text-decoration: none;\r\n  }\r\n`;\r\n\r\nexport default globalStyles;\r\n","import React from \"react\";\r\nimport Router from \"./Router\";\r\nimport GlobalStyles from \"./GlobalStyles\";\r\n\r\n// Header폴더 안에 index.js파일을 만들고 import Header from \"Components/Header\"처럼 import 하게 되면 기본적으로 Components/Header폴더 안에서 index.js파일을 찾아서 가져온다.\r\n// 원래는 Components/Header/Header를 통해 Header.js를 찾아서 가져와야 했지만 Header폴더를 따로 만들고 거기 안에 index.js를 만들어서 index.js에 Header.js를 가져오는 형태로도 만들 수 있다.\r\n// import Header2 from \"Components/Header2\";\r\n\r\nfunction App() {\r\n  return (\r\n    // 리액트에서는 두 개 이상의 컴포넌트를 리턴할 수 없는 규칙이 있다.\r\n    // 그래서 리액트에서는 아래와 같이 크게 하나의 태그로 묶어줘야 하고 이 묶어주는 태그를 Fragment라고 부른다.\r\n    <div className=\"App\">\r\n      {/* <h1>App</h1> */}\r\n      {/* <Header2></Header2> */}\r\n      <Router />\r\n      <GlobalStyles />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport App from \"Components/App\";\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById(\"root\")\r\n);\r\n"],"sourceRoot":""}